<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }

      a {
        color: #a6e22e;
      }

      .inverse {
        background: #272822;
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;
      }

      .inverse .fade {
        color: #686868;
      }



      .ide {
        background-color: #4D5052;
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;        
      }

      .antipattern {
        color: white;
        background-color: #930a11
      }

      .antipattern h1 {
        font-size: 90px;
      }

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .strike {
        color: red;
        text-decoration: line-through
      }

      .important {
        color: #a6e22e;
        text-decoration: underline;
      }

      .nolink a {
        color: #f3f3f3;
      }

      .green {
        color: #a6e22e;        
      }

      .danger {
        color: red;
      }

      .left-column {
        width: 40%;
        height: 92%;
        float: left;
      }

      .right-column {
        width: 50%;
        float: right;
        padding-top: 5em;
      }

      .title {
        color: white;
      }

      .title h1 {
        font-size: 70px;
        margin: 0;
      }



      .title .author {
        position: relative;
        top: 100px;
        text-align: right;
      }

      .title .author h3 {
        margin: 0;
      }

      .training img {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 150px;
      }

      .c4 img {
          width: 1400px
      }

    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, title
background-image: url('izbushka.jpg')
.title[
# Software Architecture 
# Anti-Patterns
]



.author[
### Eduards Sizovs 
### eduards.sizovs@gmail.com
### @eduardsi 
]

---
# "I have already did that" Architecture
... Golden Hammer
... "Instagram did that" architecture.
Experience influences software design. 
Such companies usually do marchitecture. By marchitecting by fact you ran reject developers - they are AFRAID of things they don't know. 

---
class: center, middle, antipattern
# YAGNI Architecture
???
We are all developers, and buzzwords are our fetish. Regardless of app/business complexity:

- Everything asynchronous and non-blocking (callback hell, debugging hard)
- Micro services (huge # of moving parts). 
- MongoDB (just a couple JSON documents)
- 99.99999 uptime for service that don't need that (maintenance page)

Luckily your company understands that it's the only way to keep you motivated and steps back. 
Otherwise you hit the wall and all initiaves are rejected. You say your employer, architect, colleages suck and doesn't get your idea.

Story about Marcin (without emotions, can you convince yourself that MS are really needed? How you convince customer if you don't trust yourself?)

---
class: center, middle, inverse
# Some software is never intended to stand out from the crowd.
???
Enlightment comes when you realize that some software never intended and will never to stand out of the crowd.

---
class: center, middle, inverse
# .strike[YAGNI] .important[KIND ASS] Architecture 

---
class: center, middle, inverse
# .important[K]EEP .important[I]T .important[N]EED .important[D]RIVEN .important[A]ND .important[S]IMPLE, .important[S]IR

---
class: center, middle, inverse
# .important[NEED]-DRIVEN ?
### REQUIREMENTS &bull; RISKS &bull; CONSTRAINTS

???
Architecture in the sake of architecture" doesn't work. It must be purposeful!! We have to become better at understanding needs.

Requirements 
- 99.99999 uptime? 100% data consistency? What data do we have? 
- Do you have high concurrency? What kind of ops? Can we isolate ops into separate service etc?

Risks 
- Integrations may fail and API change unexpectidly, Infrastructure may fail 
- Technology you must use evolve slowly
- MongoDB experts can win a lottery etc.

Constraints 
- Does Google have the same constraints as your company? Dev capacity? Money?
- Do you have domain expert in-house?

Shared understanding of aforementioned forces make discussions constructive and teams aligned.


---
class: center, middle, inverse
# Maslow's Hierarchy of Needs of Software Development
![](maslow.png)

---
class: center, middle, inverse
# .important[SIMPLE] ?

???
Often we work in highly demanding and inpredictable environments when a notion of "need" is not well understood.
At this stage the LAST thing you want to deal with are:
- Getting stuck with technologies you don't know (really tempting)
- Be parallelysed by choosing among alternatives
- Implement stuff for future. Because you don't know anything about the future.

---
class: center, middle, inverse
# Pick the tool you .important[know well] and ship the .important[simplest possible solution]. 
???
The winners is one who achived the goal, and not the one who fucks with computers day and night. 

---
class: center, middle, inverse
# Optimize for .important[CHANGE].
???
Don't waste time on making architecture generic/flexible (you don't know about the future and flexibility make things complex). 
Spend time on making it EASY TO UNDERSTAND and CHANGE.


---
class: center, middle, antipattern
# Nano-Service Architecture
### When SOA goes wild.
???
Almost all MS architecture goes Nano-services because it's insane to hear that a service must be of some size. SIZE of a service means NOTHING as long as it does one thing and does it well.
That said, there are many benefits, but mostly we get only troubles.

---
class: center, middle, inverse

## You think that because you understand “one” that you must therefore understand “two” because one and one make two. But you forget that you must also understand “and.”
### — Suﬁ teaching story

???
Applied to MS, you just multiple problems because you have to know how every pair of MS will work with each other.

---
class: center, middle, inverse
## By blindly splitting a system into "micro" services, you get all negative consequences with questionable benefits. 
???
Most probably you'll make things worse.

---
class: center, middle, inverse
# .strike[Micro] .important[Service-Oriented] Architecture 
### SIZE DOESN'T MATTER
???
Let's return to good old SOA which has nothing to do with SOAP, but is less confusing. 

---
class: inverse
# Driving factors for decomposition

---
class: inverse
# Driving factors for decomposition
### - Team boundaries

---
class: inverse
# Driving factors for decomposition
### - .fade[Team boundaries]
### - Frequency of change

---
class: inverse
# Driving factors for decomposition
### - .fade[Team boundaries]
### - .fade[Frequency of change]
### - Different responsibilities


---
class: inverse
# Driving factors for decomposition
### - .fade[Team boundaries]
### - .fade[Frequency of change]
### - .fade[Different responsibilities]
### - Different (cross-functional) requirements


---
class: inverse
# Driving factors for decomposition
### - .fade[Team boundaries]
### - .fade[Frequency of change]
### - .fade[Different responsibilities]
### - .fade[Different (cross-functional) requirements]
### - Different technical stack

---
class: inverse
# Driving factors for decomposition
### - .fade[Team boundaries]
### - .fade[Frequency of change]
### - .fade[Different responsibilities]
### - .fade[Different (cross-functional) requirements]
### - .fade[Different technical stack]
### - Prototyping / Experiments

---
class: center, middle, inverse
# Staying .important[BIG is OK].

---
class: center, middle, antipattern
# Structureless Architecture
???
Let's see what software structure really is

---
class: inverse
# Software Structure determines

---
class: inverse
# Software Structure determines
### - how artifacts are grouped together

---
class: inverse
# Software Structure determines
### - .fade[how artifacts are grouped together]
### - how artifacts depend on each other

---
class: inverse
# Software Structure determines
### - .fade[how artifacts are grouped together]
### - .fade[how artifacts depend on each other]
### - how artifacts build into higher level artifacts 
???
In reality most teams do not care about the structure and throw a bunch of components into a bag and shake it until it works.

---
class: inverse
# Good software structure should

---
class: inverse
# Good software structure should
### - reveal .important[high-level components]

???
- Your structure (let's say, packaging) should tell a story, revealing high-level components of your architecture and eliminate model-code gap.

---
class: inverse
# Good software structure should
### - reveal .important[high-level components]
### - reduce .important[discovery cost]

???
- Discovery cost determines how fast can you ﬁnd the code for a particular problem area to make an improvement, the source of a fault. In other words, how fast you can find a home for new code. High discovery cost impacts productivity, kills morale and, when you can't find the right place, you cut corners.

---
class: inverse
# Good software structure should
### - reveal .important[high-level components]
### - reduce .important[discovery cost]
### - improve .important[comprehensibility]

???
- Comprehensibility allows studying the system one part at a time. The whole system can therefore be better designed because it is better understood.

---
class: inverse
# Good software structure should
### - reveal .important[high-level components]
### - reduce .important[discovery cost]
### - improve .important[comprehensibility]
### - enable .important[poka-yoke]

???
- The central guiding Lean principle at work in the domain architecture is poka-yoke: enabling constraints. As programmers rush to get a feature to market they are likely to be less attentive to the gross system structure and form than to the correctness of the business logic.

---
class: middle, ide
.left-column[
  # Looks familiar?
  ![](poor-structure.png)]
.right-column[
]
???
It't funny, because it shows that all applications have the same components which is a false statement, of course

---
class: middle, ide
.left-column[
  # Looks familiar?
  ![](poor-structure.png)]
.right-column[
  ### .danger[&cross;] reveal .important[high-level components] 
]

---
class: middle, ide
.left-column[
  # Looks familiar?
  ![](poor-structure.png)]
.right-column[
  ### .danger[&cross;] reveal .important[high-level components] 
  ### .danger[&cross;] reduce .important[discovery cost]
]

---
class: middle, ide
.left-column[
  # Looks familiar?
  ![](poor-structure.png)]
.right-column[
  ### .danger[&cross;] reveal .important[high-level components] 
  ### .danger[&cross;] reduce .important[discovery cost]
  ### .danger[&cross;] improve .important[comprehensibility]
]

---
class: middle, ide
.left-column[
  # Looks familiar?
  ![](poor-structure.png)]
.right-column[
  ### .danger[&cross;] reveal .important[high-level components] 
  ### .danger[&cross;] reduce .important[discovery cost]
  ### .danger[&cross;] improve .important[comprehensibility]
  ### .danger[&cross;] enable .important[poka-yoke]
]

---
class: middle, ide
.left-column[
  # What about this?
  ![](good-structure.png)]
.right-column[
]
???
Think in services.
screaming architecture, functional structure / hierarchy is visible.

---
class: middle, ide
.left-column[
  # What about this?
  ![](good-structure.png)]
.right-column[
  ### .green[&#10004;] reveal .important[high-level components] 
]

---
class: middle, ide
.left-column[
  # What about this?
  ![](good-structure.png)]
.right-column[
  ### .green[&#10004;] reveal .important[high-level components] 
  ### .green[&#10004;] reduce .important[discovery cost]
]

???
- Maps the architecture onto a domain model that reduces the time and expense of determining where new functionality should be added (especially if we care about dependencies)

---
class: middle, ide
.left-column[
  # What about this?
  ![](good-structure.png)]
.right-column[
  ### .green[&#10004;] reveal .important[high-level components] 
  ### .green[&#10004;] reduce .important[discovery cost]
  ### .green[&#10004;] improve .important[comprehensibility]
]

???
- Analyze the code with respect to functional requirements, when all related dependencies are co-located.

---
class: middle, ide
.left-column[
  # What about this?
  ![](good-structure.png)]
.right-column[
  ### .green[&#10004;] reveal .important[high-level components] 
  ### .green[&#10004;] reduce .important[discovery cost]
  ### .green[&#10004;] improve .important[comprehensibility]
  ### .green[&#10004;] enable .important[poka-yoke]
]
???
- Such approach FORCES us to think about functional aspects and their interconnections that is often left forgotten.

---
class: center, middle, inverse
## Apply .strike[micro] .important[service-oriented] mindset to software structure. Keep services decoupled as if they were remote.
???
- Path towards micro-services. You'll see what your app is doing and whether it's doing too much.
- Interestingly, you have to keep services decoupled let them talk via API, exchange with events and try eventual consistency.

---
class: center, middle, inverse
# WHERE IS LAYERING?
![](shockedface.jpg)

---
class: center, middle, antipattern
background-image: url('lasagna.jpg')
# Lasagna Architecture
???
Logical architecture which has several (too many well-defined and separable layers, where each layer of code accesses services in the layers below through well-defined interfaces. The analogy stems from the layered structure of lasagna, where different ingredients (for example, meat, sauce, vegetables, or cheese) are each separated by strips of pasta. Also known as "onion code" because one often cries when opening so many layers.

I think we tend to overuse layering and do not benefit from it.

---
class: inverse
# Expected (.danger[doubtful]) benefits from layering

---
class: inverse
# Expected (.danger[doubtful]) benefits from layering
### - Ability to distribute your layers over multiple physical tiers (ha-ha)

---
class: inverse
# Expected (.danger[doubtful]) benefits from layering
### - .fade[Ability to distribute your layers over multiple physical tiers (ha-ha)]
### - Decoupling / abstracting for exhangeability (ha-ha)

---
class: inverse
# Expected (.danger[doubtful]) benefits from layering
### - .fade[Ability to distribute your layers over multiple physical tiers (ha-ha)]
### - .fade[Decoupling / abstracting for exhangeability (ha-ha)]
### - Decoupling / abstracting for independent evolution (ha-ha)

---
class: inverse
# Expected (.danger[doubtful]) benefits from layering
### - .fade[Ability to distribute your layers over multiple physical tiers (ha-ha)]
### - .fade[Decoupling / abstracting for exhangeability (ha-ha)]
### - .fade[Decoupling / abstracting for independent evolution (ha-ha)]
### - Decoupling for reuse (ha-ha)

---
class: inverse
# Expected (.danger[doubtful]) benefits from layering
### - .fade[Ability to distribute your layers over multiple physical tiers (ha-ha)]
### - .fade[Decoupling / abstracting for exhangeability (ha-ha)]
### - .fade[Decoupling / abstracting for independent evolution (ha-ha)]
### - .fade[Decoupling for reuse (ha-ha)]
### - Separation of concerns (is particular layer our concern?)
???
- SoC -> we end up with our concerns (functionality) scattered among layers

---
class: inverse
# Expected (.danger[doubtful]) benefits from layering
### - .fade[Ability to distribute your layers over multiple physical tiers (ha-ha)]
### - .fade[Decoupling / abstracting for exhangeability (ha-ha)]
### - .fade[Decoupling / abstracting for independent evolution (ha-ha)]
### - .fade[Decoupling for reuse (ha-ha)]
### - .fade[Separation of concerns (is particular layer our concern?)]
### - Related stuff co-location (are layers really related?)

---
class: inverse
# Expected (.danger[doubtful]) benefits from layering
### - .fade[Ability to distribute your layers over multiple physical tiers (ha-ha)]
### - .fade[Decoupling / abstracting for exhangeability (ha-ha)]
### - .fade[Decoupling / abstracting for independent evolution (ha-ha)]
### - .fade[Decoupling for reuse (ha-ha)]
### - .fade[Separation of concerns (is particular layer our concern?)]
### - .fade[Related stuff co-location (are layers really related?)]
### - Constraint enforcement (is there a better way?)
???
- CoE -> SQL cannot be written in domain model (do we really need a separate layer or just a constraint / best practice? or naming convetions, annotations, import control is OK?)


DON'T FORGET THAT WE CAN EXTRACT PARTS INTO SEPARATE LIBRARIES OR KEEP LIBRARY INTERNAL.

---
class: center, middle, inverse
# Layering is your service's .important[detail] and is .important[internal] to the service.
???
- Different services require differnet layering. That's why usually you have to move the stuff through all layers. By choosing single layering strategy we oversimplify the system and force layering model that looks god damn stupid for some services.
- it doesn't mean that services can't follow holistic approach.

---
class: center, middle, inverse
# Keep services .important[mind-sized] so there is no need for internal layering. Break services into tiny .important[modules].

### (and consider keeping modules in separate VCS tree)
???
You can split horizontally or vertically by forming service hierarchy. Utility modules for  with Time, Queues, Caching can plugged similar to 3rd party to keep your system simpler.

---
class: center, middle, antipattern
# Boundless Architecture

---
class: center, middle
# The Big Escape
![](boundaries.jpg)

---
class: middle, center, inverse
# Some parts of your system must never .danger[uncontrollably escape] to territories that are .danger[difficult to control].
???
Treat boundaries as danger zone. don’t send your code for use there.


---
class: inverse
# .danger[(!)] Don't try this at home

---
class: inverse
# .danger[(!)] Don't try this at home
### - Services know too much about each other

---
class: inverse
# .danger[(!)] Don't try this at home
### - .fade[Services know too much about each other]
### - Domain entities automatically map to RESTful Representations

???
Public APIs, like diamonds, are forever. Once  you expose something it's quite hard to rollback.

---
class: inverse
# .danger[(!)] Don't try this at home
### - .fade[Services know too much about each other]
### - .fade[Domain entities automatically map to RESTful Representations]
### - Persistent entities go outside of TX boundaries
???
Otherwise you'll have to FEAR lazy loading if you have one.

---
class: inverse
# .danger[(!)] Don't try this at home
### - .fade[Services know too much about each other]
### - .fade[Domain entities automatically map to RESTful Representations]
### - .fade[Persistent entities go outside of TX boundaries]
### - UI is formed directly from transactional domain model
???
Which make model UI-pleasing. CQRS!!!??

---
class: middle, center, inverse
# .important[Be conservative] in what you expose. .important[Take control] over what you expose.

???
What happens when there are no boundaries? (example of domain model escaping)
- Uncertainty
- Fear (touch and break client apps)
- Lost time (I have to go to apps and find usages of all domain methods...)
- Security risks
- Lack of comfort that impacts COMPREHENSIVENESS

---
class: middle, center, inverse
# Properly managed service boundaries make .important[integration testing unnecessary] (almost).

### (because integration tests are scam -> .nolink[http://goo.gl/OiCmSH])
???
You can use test doubles and contract testing.

---
class: middle, center, antipattern
# Undocumented Architecture
???
- Story about Alex Bosy (onboarding, discussions, negotiations, recalling)
- Partner-Outsourcing teams, IT Support, Compliance, Risk and Audit, Investors needs docs.
- Well, you can do it. But it's too expensive for the company and annoying for you.

---
class: middle, center, inverse
# Working software over .important[comprehensive] documentation.
### (c) Agile Manifesto
???
- Prefer != Replace
- Word comprehensive is important - it says that working software is more important than EXCESSIVE/TOO MUCH DOC, but not over good one.

---
class: middle, center, inverse
# Architecture is code!
### ...but level of abstraction of code is negligible
???
Even in the widely accepted GoF book, we find that ‘‘it’s clear that code won’t reveal everything about how a system will work.’’ We go to the code for what and how, but only the documentation tell us why. Just following the code is a bit like following a path through the woods at night. 

---
class: inverse
# Code has hard time telling you about

---
class: inverse
# Code has hard time telling you about
### - Backups, Disaster Recovery, Redundancy, Failover, ETL, SLA, etc.

---
class: inverse
# Code has hard time telling you about
### - .fade[Backups, Disaster Recovery, Redundancy, Failover, ETL, SLA, etc.]
### - Significant Decisions and Agreements (e.g. rejected frameworks)
???
- Lessons learned
- Code conventions and Principles to follow
- Quality Standards
- Definition of Done

---
class: inverse
# Code has hard time telling you about
### - .fade[Backups, Disaster Recovery, Redundancy, Failover, ETL, SLA, etc.]
### - .fade[Significant Decisions and Agreements (e.g. rejected frameworks)]
### - Surroundings (Dependencies, Service Consumers)

---
class: inverse
# Code has hard time telling you about
### - .fade[Backups, Disaster Recovery, Redundancy, Failover, ETL, SLA, etc.]
### - .fade[Significant Decisions and Agreements (e.g. rejected frameworks)]
### - .fade[Surroundings (Dependencies, Service Consumers)]
### - Onboarding (Source Repository, Building, QA, Deployment)


---
class: inverse
# Code has hard time telling you about
### - .fade[Backups, Disaster Recovery, Redundancy, Failover, ETL, SLA, etc.]
### - .fade[Significant Decisions and Agreements (e.g. rejected frameworks)]
### - .fade[Surroundings (Dependencies, Service Consumers)]
### - .fade[Onboarding (Source Repository, Building, QA, Deployment)]
### - Birdseye Technical View

---
class: inverse, center, middle
# .strike[UML] vs .important[C4]
### Context, Containers, Components, Classes

???
- No one gets UML, you have to remember all these conventions. UML is not cool. 
- Visio and tools will make things even worse - now you have tools to struggle with too.
- Find something that works for you > following world-wide rigit conventions
- C4 a set of consistent abstractions.

---
### .important[http://static.codingthearchitecture.com/c4.pdf]
.c4[![](c4.png)]
???
- In Java, you if you stick to structure we discussed before, you can even generate some diagrams
- Encourage you to learn more about C4. Simon Brown has exceptional sketching section in SaFD
---
class: inverse, center, middle
# "That’s the page I read that .important[made the difference]" 
### is a great .important[sanity check]
???
- Document only crucial parts. The rest of the time involve everybody face-to-face.
- Documentation is a reminder for those who were involved in documentation development and tutorial for those who weren’t. 
- No doc is better than shitty out-of-date doc. Must be part of DoD. (team don't doc because it's requires practice)

---

# Optimistic Architecture

You can't prevent/neglect failure. Embrace it!  (cascades, integrations, pools) etc... What happens if you run out of connection in pool? Everything fails!!!
Everything will fail glamorously.
Capacity planning - load on other nodes when some nodes goes out out service?.
fault tolerance is a lesson best learned offline 

One interesting concept they introduced is the Blast Radius. During their failure testing they explicitly analyze how far that failure reaches into the application landscape. With that information, they've tried to tune the interfaces between components to become a bit more resilient.

---
class: center, middle, antipattern
# Alchemy Architecture
???
* I feel that there are some rules,  but can't explain. And no one actually can. When I talk to colleagues, we end up in weird discussions (usually endless). 
* Lack of shared understanding. No reasonable explanation for decisions made by someone (usually some hero who drives all the architecture, which doesn't usually mean Ivory Tower, just someone more experienced than you)
* The problem is that architecture must evolve controllably. How can you take control over something you don't really understand? 

---
class: center, middle, inverse
# Wear software architect's hat by understanding and impacting current state of affairs.
???
- Apply ‘‘all hands on deck’’ mentality — everyone is in some small part an architect, and that everyone has a crucial role to play in good project beginnings. 
- Engage into decision making. Be proactive and ask for rational explanation. Challenge decisions.
- It's important to handover more decisions to teams (start small, then more and more)
- Sometimes things are pretty messy or architecture is driven by Ivory Tower. Go for external help / coaching - ask for experie if you don't have one (ask manager for architectural review). Do you want to work with sexy system or drown in BBoM? 

---
class: inverse
# What if actual architecture sucks?
???
The overal architecture is complex. Changing architecture is hard. If you're afraid or don't believe in opportunity - you already lost. You have to PULL architecture into expected direction. 

---
class: inverse
# What if actual architecture sucks?
### - Visualize actual architecture. 

---
class: inverse
# What if actual architecture sucks?
### - .fade[Visualize actual architecture.]
### - Visualize expected / ideal architecture.
???
- Especially important with legacy codebases! because old code does not serve as an example.
- Print out many copies of your architecture and pin one on the wall
- Focal point for conversations
- Feel free to draw on top of it.
---
class: inverse
# What if actual architecture sucks?
### - .fade[Visualize actual architecture.]
### - .fade[Visualize expected / ideal architecture.]
### - Iterate towards ideal.

---
class: inverse, middle, center
# Run short design sessions before diving into implementation.
???
- Together in order to share knowledge, discuss painful questions, make sure you share the same vision.
- All-the-way down.
- I should point out that there is nothing whatever wrong with spending a few hours, or even a day or two, pondering the shape of your system. There’s nothing wrong with drawing some UML, or other diagrams in order to get some ideas about how your system should be structured. I don’t want you doing this for months, but there’s nothing wrong with thinking. 

---
class: inverse, middle, center
# Run weekly meetup on issues and plan how to get better in small steps.
???
- Trello with small tech tasks
- It doesn't mean that you have to stop development or ask for management approval.
- Let's do some school math

---
class: inverse
# Change the architecture with baby steps

---
class: inverse
# Change the architecture with baby steps
### ~ 45 minutes a day / person
???
- Don't believe you can work on business tasks for 8 hours. If you can, it's counterproductive.

---
class: inverse
# Change the architecture with baby steps
### ~ .fade[45 minutes a day / person]
### ~ 4 hours a week / person

---
class: inverse
# Change the architecture with baby steps
### ~ .fade[45 minutes a day / person]
### ~ .fade[4 hours a week / person]
### ~ 20 hours a week / 5 people

---
class: inverse
# Change the architecture with baby steps
### ~ .fade[45 minutes a day / person]
### ~ .fade[4 hours a week / person]
### ~ 20 hours a week / 5 people
# No excuse for not starting .important[tomorrow].
???
- Architect working part-time :)
- Without even impacting business development, you can make you architecture a pleasure to work with!!! 


---
class: center, middle, inverse, training
# Software Architecture Essentials
### 11th of March, 2015
### Register at .important[[www.craftsmans.lv](http://www.craftsmans.lv)]
![](discount.png)

---
class: center, middle, inverse, antipattern
# Thank you!
???
I have I've challenged your thinking a bit. Thank you!

    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({

      });
    </script>
  </body>
</html>